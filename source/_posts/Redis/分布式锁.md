---
title: Redis分布式锁，看这一篇文章就够了
tags: Redis
copyright: true
abbrlink: 1168
data: 2020-05-07 20:13:35
---
今天看了一条视频，讲的还不错，使用Redis做分布式锁，面对不同的情况，都给出了解决方案

# 单体架构下加锁的方式

## 同步代码块

```java
synchronized (锁对象){
    将需要同步执行的代码放到synchronized代码块中，该代码块中的代码只能运行一个线程来执行，如果当前线程没有执行完毕，那么其他线程会在代码块外面等待，直到当前的线程执行完毕。
}
```

### 例如

```java
@RestController
public class DistributedLock {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping("/deduct_stock")
    public String deductStock(){
        //单体架构加锁
        synchronized (this){
            //自己的业务代码
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if(stock>0){
                int realStock = stock-1;
                stringRedisTemplate.opsForValue().set("stock",realStock+"");
                System.out.println("扣除成功，减少库存："+realStock);
            }else {
                System.out.println("扣除失败，库存不足");
            }
        }
        return "end";
    }
}
```

### 问题

在单体应用的情况下使用`synchronized`即可解决线程安全问题，但是如果采用集群部署，则会出现`超卖`的情况

<!--more-->

# 分布式架构使用Redis做分布式锁

## Setnx命令

**格式**：setnx  key  value

​			将`key`的值作为`value`，当且仅当`key`不存在。

​			若给定的`key`已经存在,则`SETNX`不做任何动作，

​			`SETNX`是【SET if Not eXists】 （如果不存在，则`SET`）的间歇

## 分布式锁

### 示例

```java
//加锁
String lockKey = "lockKey";
Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "001");
//业务代码
	...
    ...
    ...
    ...
//释放锁
stringRedisTemplate.delete(lockKey);        
```

### 代码示例

```java
@RestController
public class DistributedLock {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping("/deduct_stock")
    public String deductStock(){
        String lockKey = "lockKey";
        Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "001");
        if (!result){
            return "error_code";
        }
        //分布式架构
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if(stock>0){
                int realStock = stock-1;
                stringRedisTemplate.opsForValue().set("stock",realStock+"");
                System.out.println("扣除成功，减少库存："+realStock);
            }else {
                System.out.println("扣除失败，库存不足");
            }
            stringRedisTemplate.delete(lockKey);
        return "end";
    }
}
```

### 问题

如以上所示代码：一个请求过来首先设置一个锁，然后执行业务代码，执行一半的时候，系统抛出异常，这样就相当于上一个请求的锁一直没有删除掉，就会出现死锁的情况，后面所有的请求都无法执行，陷入死循环。

## 系统抛出异常解决方案

### 示例

```java
try {
            
    } finally {
            
    	}
```

### 代码示例

```java
@RestController
public class DistributedLock {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping("/deduct_stock")
    public String deductStock(){
        String lockKey = "lockKey";
        try {
            Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "001");
            if (!result){
                return "error_code";
            }
            //分布式架构
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if(stock>0){
                int realStock = stock-1;
                stringRedisTemplate.opsForValue().set("stock",realStock+"");
                System.out.println("扣除成功，减少库存："+realStock);
            }else {
                System.out.println("扣除失败，库存不足");
            }
        } finally {
            stringRedisTemplate.delete(lockKey);
        }
        return "end";
    }
}
```

### 问题

如上所示代码：虽然避免了系统抛出异常，导致出现死锁的情况，但是出现`JVM`进程被杀死的情况，`finally`中的代码依然无法执行，最后还是会出现死锁，

## JVM进程被杀死的解决方案

### 示例

```java
//stringRedisTemplate.opsForValue().setIfAbsent方法重载，设置过期时间
            Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "001",10, TimeUnit.SECONDS);
```

### 代码示例

```java
@RestController
public class DistributedLock {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping("/deduct_stock")
    public String deductStock(){
        String lockKey = "lockKey";
        try {
            //stringRedisTemplate.opsForValue().setIfAbsent方法重载，设置过期时间
            Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "001",10, TimeUnit.SECONDS);
            if (!result){
                return "error_code";
            }
            //分布式架构
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if(stock>0){
                int realStock = stock-1;
                stringRedisTemplate.opsForValue().set("stock",realStock+"");
                System.out.println("扣除成功，减少库存："+realStock);
            }else {
                System.out.println("扣除失败，库存不足");
            }
        } finally {
            stringRedisTemplate.delete(lockKey);
        }
        return "end";
    }
}
```

### 问题

假如第一个请求执行自己的业务逻辑需要15秒，但是自己设置的过期时间为10秒，这样就会出现一种情况，当第一个线程执行10秒的时候，这个锁就过期了，这时第二个线程过来执行代码，给自己加锁，这时到第15秒的时候，第一个线程任务执行完，准备释放锁，这时释放的却是第二个线程加的锁，如此就会出现无锁的情况，如此反复循环，分布式的锁也就失效了。

## 锁失效的解决方案

### 代码示例

```java
//给每一个线程锁都设置一个唯一值，将这个值作为value,每次释放锁的时候都判断下，当前key的value的值是否是当初自己设置的值，如果是就释放
String clienId = UUID.randomUUID().toString();
Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clienId,10, TimeUnit.SECONDS);
```

### 示例

```java
@RestController
public class DistributedLock {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping("/deduct_stock")
    public String deductStock(){
        String lockKey = "lockKey";
        String clienId = UUID.randomUUID().toString();
        try {
            //stringRedisTemplate.opsForValue().setIfAbsent方法重载，设置过期时间
            Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clienId,10, TimeUnit.SECONDS);
            if (!result){
                return "error_code";
            }
            //分布式架构
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if(stock>0){
                int realStock = stock-1;
                stringRedisTemplate.opsForValue().set("stock",realStock+"");
                System.out.println("扣除成功，减少库存："+realStock);
            }else {
                System.out.println("扣除失败，库存不足");
            }
        } finally {
            if(clienId.equals(stringRedisTemplate.opsForValue().get(lockKey))){
                stringRedisTemplate.delete(lockKey);
            }
        }
        return "end";
    }
}
```



